#!/usr/bin/env node
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

function readFileSafe(p){
  try{ return fs.readFileSync(p,'utf8'); }catch(e){ return ''; }
}

function extractTitle(content, fallback){
  const lines = content.split(/\r?\n/);
  for(const l of lines){
    const m = l.trim().match(/^#\s+(.+)/);
    if(m) return m[1].trim();
  }
  // fallback to first non-empty line
  for(const l of lines){ if(l.trim()) return l.trim().slice(0,120); }
  return fallback;
}

function extractSummary(content){
  const stripped = content.replace(/```[\s\S]*?```/g,'').replace(/[#>*`]/g,'').trim();
  const paras = stripped.split(/\n\s*\n/).map(s=>s.trim()).filter(Boolean);
  if(paras.length) return paras[0].slice(0,400).replace(/\s+/g,' ').trim();
  return '';
}

function gitRevisions(limit = 20){
  try{
    const out = execSync(`git log -n ${limit} --pretty=format:%ad%x1f%an%x1f%s --date=short`, { encoding: 'utf8' });
    return out.split('\n').filter(Boolean).map(line => {
      const parts = line.split('\x1f');
      return { date: parts[0], author: parts[1], note: parts[2] };
    });
  }catch(e){ return []; }
}

function buildIndex(){
  const root = process.cwd();
  const pkg = JSON.parse(readFileSafe(path.join(root,'package.json')) || '{}');

  const docsDir = path.join(root,'docs');
  const docsFiles = fs.existsSync(docsDir) ? fs.readdirSync(docsDir).filter(f=>f.endsWith('.md')).map(f=>path.join('docs',f)) : [];
  const items = [];

  docsFiles.forEach(rel => {
    const p = path.join(root, rel);
    const content = readFileSafe(p);
    items.push({ path: rel, title: extractTitle(content, rel), summary: extractSummary(content) });
  });

  const toCheck = ['server/README.md','README.md'];
  toCheck.forEach(rel => {
    const p = path.join(root, rel);
    if(fs.existsSync(p)){
      const content = readFileSafe(p);
      items.push({ path: rel, title: extractTitle(content, rel), summary: extractSummary(content) });
    }
  });

  // group by top folder
  const categories = {};
  items.forEach(it => {
    const seg = it.path.split('/')[0];
    const cat = seg || 'root';
    categories[cat] = categories[cat] || [];
    categories[cat].push({ path: it.path, title: it.title, summary: it.summary });
  });

  const index = {
    generatedAt: new Date().toISOString(),
    project: pkg.name || path.basename(root),
    overview: pkg.description || 'Documentation index autogenerated',
    categories,
    revisions: gitRevisions(20)
  };

  return index;
}

function writeIndex(){
  const out = buildIndex();
  const file = path.join(process.cwd(),'docs','documentation_index.json');
  fs.writeFileSync(file, JSON.stringify(out, null, 2)+'\n', 'utf8');
  console.log('Wrote', file);
}

if(require.main === module){
  try{ writeIndex(); }catch(e){ console.error(e); process.exit(1); }
}
